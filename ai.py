import math

import game
import core

def get_avaliable_policy(board):
    return [x for x in range(9) if board[x]==0]

# this is not correct
def get_the_best_policy(board,player_flag,opt_func = lambda x : max(x),):
    possible_policies = get_avaliable_policy(board)
    result = []
    for policy in possible_policies:
        new_board = update_board(board,policy)
        (has_empty_position,winner) = get_game_state(new_board)
        if ((not has_empty_position) or winner != 0):
            result.append((policy,winner*10/player_flag))
        else:
            (p,r)=get_the_best_policy(new_board,min if opt_func==max else max,player_flag )
            result.append((policy,r))
    return None if result == [] else opt_func(result,key=lambda x: x[1])

def max_utility(board):
    """
    Returns the max utility value given a board

    Parameters:
    board (list): A list of size 9 representing the game board in finished state

    Returns:
    int: the maximum utility values generated by possible plies
    """
    state = core.get_game_state(board)
    if state[0] != 1 or state[1] != 0:
        return utility(board)
    else:
        value = -math.inf
        for action in get_available_policy(board):
            value = max(value, max_utility(game.update_board(action)))
        return value

def utility(board):
    """
    Returns the utility value of the board given a finished board

    Parameters:
    board (list): A list of size 9 representing the game board in finished state

    Returns:
    int: 10 if the first hand wins, -10 if the last hand wins
         0 if it's a time
    """
    state = core.get_game_state(board)
    if state[1] == 1:
        return 10
    elif state[1] == -1:
        return -10
    else:
        return 0
